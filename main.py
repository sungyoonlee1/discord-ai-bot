# ‚úÖ main.py
Í≥µÏßÄÏÇ¨Ìï≠Ï±ÑÎÑêID = 1381470992551120982
import discord
from discord.ext import commands
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.date import DateTrigger
from datetime import datetime, timedelta
import pytz
import os
import json
import asyncio
import random
from dotenv import load_dotenv
from ocr_analyzer import analyze_image_and_feedback

load_dotenv()
TOKEN = os.getenv("DISCORD_BOT_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents)
scheduler = AsyncIOScheduler()

KST = pytz.timezone("Asia/Seoul")
SUBMIT_FILE = "submitted_users.json"
PAYBACK_FILE = "payback_records.json"
ALLOWED_ITEMS = ["planner", "lunch", "dinner", "checkout"]

def schedule_auth(user, channel, tag, time_str):
    try:
        target_time = datetime.strptime(time_str, "%H:%M").replace(
            year=datetime.now(KST).year,
            month=datetime.now(KST).month,
            day=datetime.now(KST).day,
            tzinfo=KST
        )
        alarm_time = target_time - timedelta(minutes=2)

        if alarm_time < datetime.now(KST):
            return  # Í≥ºÍ±∞Îäî Î¨¥Ïãú

        # Ïù∏Ï¶ù ÏöîÏ≤≠ ÏòàÏïΩ
        scheduler.add_job(send_auth, DateTrigger(run_date=alarm_time), args=[user, channel, tag])

        # Ïù∏Ï¶ù Ïã§Ìå® ÏïåÎ¶º ÏòàÏïΩ
        key = f"{user.id}-{tag}"
        scheduler.add_job(check_and_alert, DateTrigger(run_date=target_time), args=[user, channel, key])

        # ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∏∞Î°ù
        pending = load_json("pending_check.json")
        pending[key] = alarm_time.strftime("%Y-%m-%d %H:%M:%S")
        save_json("pending_check.json", pending)

        # ‚úÖ Ï∂îÍ∞Ä: Ïù∏Ï¶ù ÏãúÍ∞ÑÎåÄÏóêÎßå on Î™®Îìú ÏÑ§Ï†ï
        mode_map = {
            "Ï†êÏã¨ Ï†Ñ": "lunch",
            "Ï†ÄÎÖÅ Ï†Ñ": "dinner",
            "Í≥µÎ∂Ä Ï¢ÖÎ£å Ï†Ñ": "checkout"
        }
        if tag in mode_map:
            schedule_mode_switch(user.id, mode_map[tag], time_str)

    except Exception as e:
        print(f"[ERROR] Ïù∏Ï¶ù ÏòàÏïΩ Ïã§Ìå®: {e}")  # ‚Üê Ïù¥ Ï§ÑÏù¥ Î∞òÎìúÏãú ÌïÑÏöîÌï¥!

# Ïó¨Í∏∞ÏÑúÎ∂ÄÌÑ∞Îäî try Î∞ñÏóêÏÑú Ï†ïÏùò
def set_user_mode(user_id, new_mode):
    update_user_state(user_id, current_mode=new_mode)

def reset_user_mode(user_id):
    update_user_state(user_id, current_mode="off")

def schedule_mode_switch(user_id, mode, time_str):
    try:
        target_time = datetime.strptime(time_str, "%H:%M").replace(
            year=datetime.now(KST).year,
            month=datetime.now(KST).month,
            day=datetime.now(KST).day,
            tzinfo=KST
        )
        scheduler.add_job(set_user_mode, DateTrigger(run_date=target_time - timedelta(minutes=2)), args=[user_id, mode])
        scheduler.add_job(reset_user_mode, DateTrigger(run_date=target_time + timedelta(minutes=2)), args=[user_id])
    except Exception as e:
        print(f"[ERROR] Î™®Îìú ÏòàÏïΩ Ïã§Ìå®: {e}")

def load_json(file):
    return json.load(open(file, encoding="utf-8")) if os.path.exists(file) else {}

def save_json(file, data):
    with open(file, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

USER_STATE_FILE = "user_state.json"

def load_user_state():
    return load_json(USER_STATE_FILE)

def save_user_state(data):
    save_json(USER_STATE_FILE, data)

def update_user_state(user_id, **kwargs):
    uid = str(user_id)
    data = load_user_state()
    if uid not in data:
        data[uid] = {
            "planner_submitted": False,
            "lunch_time": None,
            "dinner_time": None,
            "end_time": None,
            "current_mode": "on",
            "last_updated": datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S")
        }
    for k, v in kwargs.items():
        data[uid][k] = v
    data[uid]["last_updated"] = datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S")
    save_user_state(data)
    
def save_submission(user_id):
    today = datetime.now(KST).strftime("%Y-%m-%d")
    data = load_json(SUBMIT_FILE)
    if today not in data: data[today] = []
    if user_id not in data[today]:
        data[today].append(user_id)
    save_json(SUBMIT_FILE, data)

def add_payback(user_id, item):
    today = datetime.now(KST).strftime("%Y-%m-%d")
    data = load_json(PAYBACK_FILE)
    if user_id not in data: data[user_id] = {}
    if today not in data[user_id]:
        data[user_id][today] = {"total": 0, "items": []}
    rec = data[user_id][today]
    if rec["total"] < 1000 and item not in rec["items"]:
        rec["items"].append(item)
        rec["total"] += 250
    save_json(PAYBACK_FILE, data)

async def send_announcement(channel_id, message):
    channel = bot.get_channel(channel_id)
    if channel:
        await channel.send(message)

async def send_auth(user, channel, tag):
    today = datetime.now(KST).strftime("%Y-%m-%d")
    submitted = load_json(SUBMIT_FILE).get(today, {})
    user_id = str(user.id)

    # Í∏∞Î≥∏ Î©îÏãúÏßÄ
    base_msg = f"{user.mention}Îãò, üì∏ **{tag} Ïù∏Ï¶ù ÏãúÍ∞Ñ**ÏûÖÎãàÎã§! ÏÇ¨ÏßÑÏùÑ Î≥¥ÎÇ¥Ï£ºÏÑ∏Ïöî."

    # planner Ï†úÏ∂úÏûêÎùºÎ©¥ ÎûúÎç§ Î≤îÏúÑ ÏöîÏ≤≠ Ï∂îÍ∞Ä
    if user_id in submitted:
        try:
            text = submitted[user_id]
            lines = [line.strip() for line in text.split("\n") if line.strip()]
            chosen = random.choice(lines)
            base_msg += f"\nüìù Ï∂îÍ∞Ä Ïù∏Ï¶ù ÏöîÏ≤≠: `{chosen}` Í≥µÎ∂Ä Ïù∏Ï¶ù ÏÇ¨ÏßÑÎèÑ Ìï®Íªò Î≥¥ÎÇ¥Ï£ºÏÑ∏Ïöî!"
        except Exception as e:
            print(f"[ERROR] Ïù∏Ï¶ù Î≤îÏúÑ Ï∂îÏ∂ú Ïã§Ìå®: {e}")

    await channel.send(base_msg)

async def check_and_alert(user, channel, key):
    today = datetime.now(KST).strftime("%Y-%m-%d")
    verified = load_json("verified_users.json")
    if verified.get(today, {}).get(key) != True:
        await channel.send(f"{user.mention}Îãò, ‚õî `{key.split('-')[1]}` Ïù∏Ï¶ùÏùÑ 2Î∂Ñ ÎÇ¥Ïóê ÏôÑÎ£åÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÌéòÏù¥Î∞±Ïù¥ Ï†ÅÏö©ÎêòÏßÄ ÏïäÏäµÎãàÎã§.")

async def check_missed():
    await bot.wait_until_ready()
    today = datetime.now(KST).strftime("%Y-%m-%d")
    submitted = load_json(SUBMIT_FILE).get(today, [])
    for g in bot.guilds:
        for m in g.members:
            if m.bot: continue
            if str(m.id) not in submitted:
                ch = discord.utils.get(g.text_channels, name=f"{m.name}-ÎπÑÏÑú")
                if ch:
                    await ch.send(f"{m.mention}Îãò, Ïò§Îäò Ïò§Ï†Ñ 9ÏãúÍπåÏßÄ ÌîåÎûòÎÑà ÎØ∏Ï†úÏ∂úÎ°ú **ÌéòÏù¥Î∞± Ï†úÏô∏** ‚ùå")

@bot.event
async def on_ready():
    print(f"‚úÖ Logged in as {bot.user}")
    scheduler.add_job(check_missed, "cron", hour=9, minute=0, timezone=KST)
    scheduler.add_job(send_announcement, "cron", hour=8, minute=0, timezone=KST,
                      args=[Í≥µÏßÄÏÇ¨Ìï≠Ï±ÑÎÑêID, "üì¢ ÌîåÎûòÎÑà Ïù∏Ï¶ù ÏãúÍ∞ÑÏûÖÎãàÎã§! Ïò§Ï†Ñ 9ÏãúÍπåÏßÄ Ï†úÏ∂úÌï¥ Ï£ºÏÑ∏Ïöî."])
    scheduler.add_job(reset_all_user_modes, "cron", hour=8, minute=0, timezone=KST)
    scheduler.add_job(send_announcement, "cron", hour=9, minute=0, timezone=KST,
                      args=[Í≥µÏßÄÏÇ¨Ìï≠Ï±ÑÎÑêID, "‚õî Ïò§Ï†Ñ 9Ïãú ÎßàÍ∞ê! Ïù¥Ï†ú Ï†úÏ∂úÌï¥ÎèÑ ÌéòÏù¥Î∞±ÏùÄ Î∂àÍ∞ÄÌï©ÎãàÎã§."])
    scheduler.start()

@bot.event
async def on_member_join(member):
    guild = member.guild
    name = f"{member.name}-ÎπÑÏÑú"
    cat = discord.utils.get(guild.categories, name="üìÅ ÌïôÏÉùÎπÑÏÑú")
    if not cat:
        cat = await guild.create_category("üìÅ ÌïôÏÉùÎπÑÏÑú")
    perms = {
        guild.default_role: discord.PermissionOverwrite(read_messages=False),
        member: discord.PermissionOverwrite(read_messages=True, send_messages=True),
        guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
    }
    ch = await guild.create_text_channel(name=name, category=cat, overwrites=perms)
    await ch.send(f"{member.mention}Îãò, Ï†ÑÏö© Í≥µÎ∂Ä ÎπÑÏÑú Ï±ÑÎÑêÏù¥ ÏÉùÏÑ±ÎêêÏäµÎãàÎã§.\nüì∏ **ÏïÑÏπ® 9Ïãú Ï†ÑÍπåÏßÄ ÌîåÎûòÎÑàÎ•º Ï†úÏ∂ú**ÌïòÎ©¥ ÌéòÏù¥Î∞± ÎåÄÏÉÅÏù¥ Îê©ÎãàÎã§!")

@bot.command()
async def ÌéòÏù¥Î∞±(ctx):
    uid = str(ctx.author.id)
    today = datetime.now(KST).strftime("%Y-%m-%d")
    data = load_json(PAYBACK_FILE).get(uid, {})
    amt = data.get(today, {}).get("total", 0)
    await ctx.send(f"üí∏ Ïò§Îäò ÌéòÏù¥Î∞±: **{amt}Ïõê**")

def reset_all_user_modes():
    data = load_user_state()
    for uid in data:
        data[uid]["current_mode"] = "on"
        data[uid]["last_updated"] = datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S")
    save_user_state(data)

@bot.event
async def on_message(msg):
    if msg.author.bot:
        return

    now = datetime.now(KST)

    # 1Ô∏è‚É£ 00Ïãú ~ 08Ïãú: ÏÇ¨ÏßÑ Î¨¥Ïãú
    if now.hour < 8:
        return

    # 2Ô∏è‚É£ ÏÇ¨ÏßÑÎßå Î≥¥ÎÉàÎäîÏßÄ ÌôïÏù∏
    if not msg.attachments or msg.content.strip():
        return

    uid = str(msg.author.id)
    state = load_user_state().get(uid, {})
    mode = state.get("current_mode", "off")
    submitted = state.get("planner_submitted", False)

    # 3Ô∏è‚É£ ÌîåÎûòÎÑà ÏûêÎèô Î∂ÑÏÑù (Î™®ÎìúÍ∞Ä onÏù¥Í≥† ÏïÑÏßÅ Ï†úÏ∂ú Ïïà ÎêêÏùÑ Îïå)
    if mode == "on" and not submitted:
        img_bytes = await msg.attachments[0].read()
        result = await analyze_image_and_feedback(img_bytes)

        if "error" in result:
            return await msg.channel.send(f"‚ùå GPT Î∂ÑÏÑù Ïã§Ìå®: {result['error']}")

        update_user_state(uid, current_mode="off", planner_submitted=True)
        save_submission(uid)
        add_payback(uid, "planner")

        schedule_auth(msg.author, msg.channel, "Ï†êÏã¨ Ï†Ñ", result["lunch"])
        schedule_auth(msg.author, msg.channel, "Ï†ÄÎÖÅ Ï†Ñ", result["dinner"])
        schedule_auth(msg.author, msg.channel, "Í≥µÎ∂Ä Ï¢ÖÎ£å Ï†Ñ", result["end"])

        return await msg.channel.send(
            f"‚úÖ ÌîåÎûòÎÑà Ï†úÏ∂ú ÏôÑÎ£å + ÌéòÏù¥Î∞± Ï†ÅÏö©!\nüìä Î∂ÑÏÑùÍ≤∞Í≥º: {result}"
        )

    # 4Ô∏è‚É£ Ïù∏Ï¶ù ÏãúÍ∞ÑÎåÄ ÏùëÎãµ (lunch/dinner/checkout)
    if mode not in ["lunch", "dinner", "checkout"]:
        return

    if not submitted:
        return  # ÌîåÎûòÎÑà Ï†úÏ∂ú Ïïà ÌñàÏúºÎ©¥ Î¨¥Ïãú

    mode_map = {
        "lunch": "Ï†êÏã¨ Ï†Ñ",
        "dinner": "Ï†ÄÎÖÅ Ï†Ñ",
        "checkout": "Í≥µÎ∂Ä Ï¢ÖÎ£å Ï†Ñ"
    }
    tag = mode_map[mode]
    key = f"{uid}-{tag}"

    verified = load_json("verified_users.json")
    today = datetime.now(KST).strftime("%Y-%m-%d")
    if today not in verified:
        verified[today] = {}
    verified[today][key] = True
    save_json("verified_users.json", verified)

    pending = load_json("pending_check.json")
    if key in pending:
        expire_time = datetime.strptime(pending[key], "%Y-%m-%d %H:%M:%S").replace(tzinfo=KST) + timedelta(minutes=2)
        if datetime.now(KST) > expire_time:
            return await msg.channel.send(f"‚è∞ `{mode}` Ïù∏Ï¶ù ÏãúÍ∞ÑÏù¥ ÏßÄÎÇ¨ÏäµÎãàÎã§. ÌéòÏù¥Î∞±Ïù¥ Ï†ÅÏö©ÎêòÏßÄ ÏïäÏäµÎãàÎã§.")

    save_submission(uid)
    add_payback(uid, mode)
    return await msg.channel.send(f"‚úÖ `{mode}` Ïù∏Ï¶ù ÏôÑÎ£å + ÌéòÏù¥Î∞± Ï†ÅÏö©!")

    # 5Ô∏è‚É£ Î™ÖÎ†πÏñ¥ Ï≤òÎ¶¨
    await bot.process_commands(msg)

if __name__ == "__main__":
    asyncio.run(bot.start(TOKEN))
